<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lab1 – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-dfb324f25d9b1687192fa8be62ac8f9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../labs/lab1/lab1.html" aria-current="page"> 
<span class="menu-text">Lab 1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/lab2/lab2.html"> 
<span class="menu-text">Lab 2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/lab3/lab3.html"> 
<span class="menu-text">Lab 3</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/lab4/lab4.html"> 
<span class="menu-text">Lab 4</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/lab5/lab5.html"> 
<span class="menu-text">Lab 5</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/lab6/lab6.html"> 
<span class="menu-text">Lab 6</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs/lab7/lab7.html"> 
<span class="menu-text">Lab 7</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#design-and-testing-methodology" id="toc-design-and-testing-methodology" class="nav-link" data-scroll-target="#design-and-testing-methodology">Design and Testing Methodology</a></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation</a>
  <ul class="collapse">
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#schematic" id="toc-schematic" class="nav-link" data-scroll-target="#schematic">Schematic</a></li>
  </ul></li>
  <li><a href="#results-and-discussion" id="toc-results-and-discussion" class="nav-link" data-scroll-target="#results-and-discussion">Results and Discussion</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#ai-prototype-summary" id="toc-ai-prototype-summary" class="nav-link" data-scroll-target="#ai-prototype-summary">AI Prototype Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Lab #1 involved the configuration and testing of the E155 development board. First, all the necessary parts were soldered per the <a href="https://hmc-e155.github.io/assets/doc/E155%20Development%20Board%20Schematic.pdf">project board schematic</a>. Then, to confirm functionality of the FPGA, the board was programmed so that the onboard LED would blink at a rate of 2.4Hz, using the onboard high speed oscillator (HSOSC). Then, the board was used to control a 7 segment display, with the input coming from a set of switches on the board, and the display showing the corresponding hex digit.</p>
</section>
<section id="design-and-testing-methodology" class="level1">
<h1>Design and Testing Methodology</h1>
<p>The soldering included both SMD and TMD parts to a given PCB.</p>
<p>The LED was driven by using the HSOSC at 24MHz and a counter to divide the signal so that the LED could blink at the desired 2.4Hz. Two other LEDs were meant to be driven, but as of right now, they are absent from the board due to materials constraints.</p>
<p>The 7-segment display was driven using a module involving a simple case statement, that evaluated the input from the onboard switches, then reflected that value in hex. The display was connected to pins off the FGPA, and each segment was turned on</p>
</section>
<section id="technical-documentation" class="level1">
<h1>Technical Documentation</h1>
<p>The code for the project can be found in this <a href="https://github.com/wchan03/e155Lab1">Github repository</a></p>
<p>The main module is as shown below:</p>
<p>’// Wava Chan // wchan@g.hmc.edu // Aug.&nbsp;29, 2025 // Main module for testing operation of project board</p>
<p>module lab1_wc( input logic [3:0] s, output logic [2:0] led, output logic [6:0] seg);</p>
<pre><code>logic int_osc; // Internal clock
logic [32:0] counter;

// Segment display module
seg_disp sd(s, seg);

// START CODE FROM TUTORIAL
// Internal high-speed oscillator
HSOSC #(.CLKHF_DIV(2'b01)) 
        hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));

// Counter
always_ff @(posedge int_osc) begin  
    counter &lt;= counter + 33'd859;
end

// Assign LED output
assign led[0] = s[1] ^ s[0];
assign led[1] = s[3] &amp; s[2];
assign led[2] = counter[32];
        
// END CODE FROM TUTORIAL </code></pre>
<p>endmodule ’</p>
<p>This includes a module called seg_disp, which consists of:</p>
<p>’// Wava Chan // wchan@g.hmc.edu // Aug.&nbsp;29, 2025 // seg_disp determines which segments must be turned on for each hexidec digit</p>
<p>module seg_disp(input logic [3:0] s, output logic [6:0] seg ); logic [6:0] seg_intm; always_comb begin // seg[0] is A // seg[6] is G case(s) 4’b0000: seg_intm &lt;= 7’b0111111; //0 4’b0001: seg_intm &lt;= 7’b0000110; //1 4’b0010: seg_intm &lt;= 7’b1011011; //2 4’b0011: seg_intm &lt;= 7’b1001111; //3 4’b0100: seg_intm &lt;= 7’b1100110; //4 4’b0101: seg_intm &lt;= 7’b1101101; //5 4’b0110: seg_intm &lt;= 7’b1111101; //6 4’b0111: seg_intm &lt;= 7’b0000111; //7 4’b1000: seg_intm &lt;= 7’b1111111; //8 4’b1001: seg_intm &lt;= 7’b1101111; //9 4’b1010: seg_intm &lt;= 7’b1110111; //A 4’b1011: seg_intm &lt;= 7’b1111100; //B 4’b1100: seg_intm &lt;= 7’b1011000; //C 4’b1101: seg_intm &lt;= 7’b1011110; //D 4’b1110: seg_intm &lt;= 7’b1111001; //E 4’b1111: seg_intm &lt;= 7’b1110001; //F default: seg_intm &lt;= 7’b1111111; endcase seg &lt;= ~seg_intm; // Flip all bits to pull segments DOWN to turn them on end endmodule’</p>
<section id="block-diagram" class="level2">
<h2 class="anchored" data-anchor-id="block-diagram">Block Diagram</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lab1_blockdiagram.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1. Block Diagram of HDL code</figcaption>
</figure>
</div>
</section>
<section id="schematic" class="level2">
<h2 class="anchored" data-anchor-id="schematic">Schematic</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lab1_schematic.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2. Schematic of breadboard ciruit</figcaption>
</figure>
</div>
</section>
</section>
<section id="results-and-discussion" class="level1">
<h1>Results and Discussion</h1>
<p>The design met all intended objectives. The LED blinks at the desired rate, and the 7 segment display correctly produces digits 0-F based on input from the switches.</p>
<p>However, it proved difficult to run the QuestaSim testbench simulation. This aspect would need more work, but the design is verified by physical testing.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>The design was able to successfully operate a 7-segment display as well as drive the on-board LED using the HSOSC. I spent 15 hours working on this lab.</p>
</section>
<section id="ai-prototype-summary" class="level1">
<h1>AI Prototype Summary</h1>
<p>I fed ChatGPT the given prompt, and it produced the below code</p>
<p>module led_blink_2hz ( output logic led );</p>
<pre><code>// Internal oscillator signal
logic clk_48mhz;
logic hfosc_en = 1'b1;
logic hfosc_ready;

// Instantiate the internal high-frequency oscillator
SB_HFOSC #(
    .CLKHF_DIV("0b00")  // "00" = 48 MHz, "01" = 24 MHz, etc.
) hfosc_inst (
    .CLKHFEN(hfosc_en),     // Enable the oscillator
    .CLKHFPU(hfosc_en),     // Power up the oscillator
    .CLKHF(clk_48mhz)       // Output clock signal
);

// Counter for clock division
logic [24:0] counter = 25'd0;  // Enough bits to count to 24,000,000
logic led_state = 0;

always_ff @(posedge clk_48mhz) begin
    if (counter == 24_000_000 - 1) begin
        counter &lt;= 0;
        led_state &lt;= ~led_state;  // Toggle LED every 0.5s → 2 Hz
    end else begin
        counter &lt;= counter + 1;
    end
end

assign led = led_state;</code></pre>
<p>endmodule `</p>
<p>As well as some helpful notes about the prompt and the output:</p>
<p><img src="images/ai_prompt1.png" class="img-fluid"> <img src="images/ai_prompt2.png" class="img-fluid"> <img src="images/ai_prompt3.png" class="img-fluid"> <img src="images/ai_prompt4.png" class="img-fluid"></p>
<p>However, the code did not sythesize, and produced the error:</p>
<p>Error 35901063 Synthesis ERROR &lt;35901063&gt; - c:/users/wchan/documents/github/e155lab1/ai_prompt/source/impl_1/ai_prompt.sv(17): instantiating unknown module SB_HFOSC. VERI-1063 [ai_prompt.sv:17]</p>
<p>I fed this error back into ChatGPT, and it did give me code it claimed was corrected.</p>
<p>module led_blink_2hz ( output logic led );</p>
<pre><code>// Internal oscillator signal
logic clk_int;

// Instantiate internal oscillator (OSCH: ~2.08 MHz)
OSCH #(
    .NOM_FREQ("2.08")  // Nominal frequency in MHz
) osc_inst (
    .STDBY(1'b0),       // 0 = oscillator enabled
    .OSC(clk_int),      // Output clock
    .SEDSTDBY()         // Unused standby status output
);

// Calculate toggle rate for 2 Hz blink using 2.08 MHz clock
// 2.08 MHz / 4,160,000 = 0.5s toggle rate (i.e., 2 Hz)
localparam int TOGGLE_COUNT = 1_040_000;  // Toggle every 0.5s

logic [20:0] counter = 0;
logic led_state = 0;

always_ff @(posedge clk_int) begin
    if (counter == TOGGLE_COUNT - 1) begin
        counter &lt;= 0;
        led_state &lt;= ~led_state;
    end else begin
        counter &lt;= counter + 1;
    end
end

assign led = led_state;</code></pre>
<p>endmodule ’</p>
<p>However, another error is thrown:</p>
<p>Error 35901063 Synthesis ERROR &lt;35901063&gt; - c:/users/wchan/documents/github/e155lab1/ai_prompt/source/impl_1/ai_prompt.sv(15): instantiating unknown module OSCH. VERI-1063 [ai_prompt.sv:15]</p>
<p>Obviously, ChatGPT is unfamiliar with my exact system specifications, creating the need for manual debugging.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/wchan03\.github\.io\/e155Website\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>